// TODO:
//      Proper type file
//      Piping between files
//      Node range generation in grapher
//      Variables extraction in Parser
//      Replace Dictionary with Map maybe
//      Use AST's
//      Discr Unions in Parsing to build statements
//      ArrayAssignment in Analysis

open System
open System.Collections.Generic

type TFtypes = 
    | Boolean
    | Assignment
    | Skip
    | ArrayAssignment

type Edge = 
    {Q1 : int;
    Q2 : int;
    Action : string;
    Type : TFtypes}

//  INPUTS

// Edges: This should come from graph generation
let Edges = [{Q1 = 0; Q2 = 1; Action = "true"; Type = Boolean;};
            {Q1 = 1; Q2 = 2; Action = "skip"; Type = Skip;};
            {Q1 = 2; Q2 = 3; Action = "x:=0"; Type = Assignment;};
            {Q1 = 0; Q2 = 4; Action = "!(true)"; Type = Boolean;};
            {Q1 = 4; Q2 = 5; Action = "x:=0"; Type = Assignment;}; 
            {Q1 = 5; Q2 = 3; Action = "y:=1"; Type = Assignment;}; 
            {Q1 = 3; Q2 = 6; Action = "skip"; Type = Skip;}]

// Nodes: This should come from the graph generation (Hint: range(0,largest nr found))
let Nodes = [0; 1; 2; 3; 4; 5; 6]

// Variables: This should come from the parser
let Variables = ["x"; "y"]




//Generated Code Section: Domain type

// Discriminated union: names must be in uppercase
type union1 = 
    | Q of int
    | Val of string // if it is "?"


type sigma =
    {Var : string;
    Q1 : union1;
    Q2 : int
    }

//Generated by TF
let rec genIota vars oldIota =
    match vars with
    | [] -> oldIota
    | var::next -> genIota next (Set.union oldIota (Set.empty.Add({Var = var; Q1 = Val("?"); Q2 = 0})))
    
let iota = genIota Variables Set.empty
let init = Set.empty
printfn "Iota:\n%A\n" (Seq.toList iota)


//Generated code: TF
let TF_Boolean inSigma edge= inSigma

let rec remove inSet outSet killCond = 
    match inSet with
    | [] -> outSet
    | x::xs when x.Var=killCond -> remove xs outSet killCond
    | x::xs -> remove xs (Set.union outSet (Set.empty.Add(x))) killCond

let TF_Assignment (inSigma:sigma Set) (edge:Edge) = (Set.union (Set.empty.Add({Var = (edge.Action.Split ':').[0]; Q1 = Q(edge.Q1) ;Q2 = edge.Q2})) (remove (Set.toList inSigma) Set.empty (edge.Action.Split ':').[0]))

let TF_Skip inSigma edge = inSigma


// Generic Code
let AnalysisResult = new Dictionary<int, sigma Set>()

let rec initializeSigma nList = 
    match nList with
    | [] -> printfn ""
    | x::xs -> AnalysisResult.Add(x, init);
               initializeSigma xs

               
initializeSigma Nodes
AnalysisResult.Remove 0
AnalysisResult.Add(0, iota)
printfn "Initial analysis result:\n%A\n" (Seq.toList AnalysisResult)

let rec genWorklist lEdges oldSet = 
    match lEdges with
    | [] -> oldSet
    | x::xs -> ( genWorklist xs (Set.union oldSet (Set.empty.Add(x))) )

//let worklist = genWorklist [0..Edges.Length-1] Set.empty
//printfn "Worklist:\n%A\n" worklist

let mutable oldSet = Set.empty

let rec Analysis edgeList = 
    match edgeList with
    | [] -> AnalysisResult
    | edge1::edgeL -> 
        match edge1.Type with
        | Boolean -> if Set.isSubset (TF_Boolean AnalysisResult.[edge1.Q1] edge1) AnalysisResult.[edge1.Q2] then 
                        Analysis edgeL
                     else
                        oldSet <- AnalysisResult.[edge1.Q2]
                        AnalysisResult.Remove edge1.Q2
                        AnalysisResult.Add(edge1.Q2, (Set.union oldSet (TF_Boolean AnalysisResult.[edge1.Q1] edge1)))
                        Analysis Edges
        
        | Assignment -> if Set.isSubset (TF_Assignment (AnalysisResult.Item(edge1.Q1)) edge1) AnalysisResult.[edge1.Q2] then  
                            Analysis edgeL
                        else
                            oldSet <- AnalysisResult.[edge1.Q2]
                            AnalysisResult.Remove edge1.Q2
                            AnalysisResult.Add(edge1.Q2, (Set.union oldSet (TF_Assignment AnalysisResult.[edge1.Q1] edge1)))
                            Analysis Edges
                            
        | Skip -> if Set.isSubset (TF_Skip AnalysisResult.[edge1.Q1] edge1) AnalysisResult.[edge1.Q2] then
                    Analysis edgeL
                  else
                    oldSet <- AnalysisResult.[edge1.Q2]
                    AnalysisResult.Remove edge1.Q2
                    AnalysisResult.Add(edge1.Q2, (Set.union oldSet (TF_Skip AnalysisResult.[edge1.Q1] edge1)))
                    Analysis Edges
        
        | ArrayAssignment -> 
 
Analysis Edges 


printfn "Final Result:\n%A" (Seq.toList AnalysisResult)
printfn "Result Node 3:\n%A" (AnalysisResult.[3])
printfn "Result Node 6:\n%A" (AnalysisResult.[6])