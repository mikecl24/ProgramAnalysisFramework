module Analysis

//  INPUTS

// Nodes: This should come from the graph generation (Hint: range(0,largest nr found))
let Nodes = [0; 1; 2]

// Variables: This should come from the parser
let Variables = ["x"]




//Generated Code Section: Domain type

// Discriminated union: names must be in uppercase
type union1 = 
    | Q of int
    | Val of string // if it is "?"


type sigma =
    {Var : string;
    Q1 : union1;
    Q2 : int
    }

//Generated by TF
let rec genIota vars oldIota =
    match vars with
    | [] -> oldIota
    | var::next -> genIota next (Set.union oldIota (Set.empty.Add({Var = var; Q1 = Val("?"); Q2 = 0})))
    
let iota = genIota Variables Set.empty
let init = Set.empty
printfn "Iota:\n%A\n" (Seq.toList iota)


//Generated code: TF
let TF_Boolean inSigma edge= inSigma

let rec remove inSet outSet killCond = 
    match inSet with
    | [] -> outSet
    | x::xs when x.Var=killCond -> remove xs outSet killCond
    | x::xs -> remove xs (Set.union outSet (Set.empty.Add(x))) killCond

let TF_Assignment (inSigma:sigma Set) (edge:Edge) = (Set.union (Set.empty.Add({Var = (edge.Action.Split ':').[0]; Q1 = Q(edge.Q1) ;Q2 = edge.Q2})) (remove (Set.toList inSigma) Set.empty (edge.Action.Split ':').[0]))

let TF_Skip inSigma edge = inSigma

// May not kill in arrays
let TF_ArrayAssignment (inSigma:sigma Set) (edge:Edge) = (Set.union (Set.empty.Add({Var = (edge.Action.Split '[').[0]; Q1 = Q(edge.Q1) ;Q2 = edge.Q2})) inSigma)


// Generic Code
let AnalysisResult = new Dictionary<int, sigma Set>()

let rec initializeSigma nList = 
    match nList with
    | [] -> printfn ""
    | x::xs -> AnalysisResult.Add(x, init);
               initializeSigma xs

               
initializeSigma Nodes
AnalysisResult.Remove 0
AnalysisResult.Add(0, iota)
printfn "Initial analysis result:\n%A\n" (Seq.toList AnalysisResult)

let rec genWorklist lEdges oldSet = 
    match lEdges with
    | [] -> oldSet
    | x::xs -> ( genWorklist xs (Set.union oldSet (Set.empty.Add(x))) )

//let worklist = genWorklist [0..Edges.Length-1] Set.empty
//printfn "Worklist:\n%A\n" worklist

let mutable oldSet = Set.empty

let rec Analysis edgeList Edges = 
    match edgeList with
    | [] -> AnalysisResult
    | edge1::edgeL -> 
        match edge1.Type with
        | Boolean -> if Set.isSubset (TF_Boolean AnalysisResult.[edge1.Q1] edge1) AnalysisResult.[edge1.Q2] then 
                        Analysis edgeL Edges
                     else
                        oldSet <- AnalysisResult.[edge1.Q2]
                        AnalysisResult.Remove edge1.Q2
                        AnalysisResult.Add(edge1.Q2, (Set.union oldSet (TF_Boolean AnalysisResult.[edge1.Q1] edge1)))
                        Analysis Edges Edges
        
        | Assignment -> if Set.isSubset (TF_Assignment (AnalysisResult.Item(edge1.Q1)) edge1) AnalysisResult.[edge1.Q2] then  
                            Analysis edgeL Edges
                        else
                            oldSet <- AnalysisResult.[edge1.Q2]
                            AnalysisResult.Remove edge1.Q2
                            AnalysisResult.Add(edge1.Q2, (Set.union oldSet (TF_Assignment AnalysisResult.[edge1.Q1] edge1)))
                            Analysis Edges Edges
                            
        | Skip -> if Set.isSubset (TF_Skip AnalysisResult.[edge1.Q1] edge1) AnalysisResult.[edge1.Q2] then
                    Analysis edgeL Edges
                  else
                    oldSet <- AnalysisResult.[edge1.Q2]
                    AnalysisResult.Remove edge1.Q2
                    AnalysisResult.Add(edge1.Q2, (Set.union oldSet (TF_Skip AnalysisResult.[edge1.Q1] edge1)))
                    Analysis Edges Edges
        
        | ArrayAssignment -> if Set.isSubset (TF_ArrayAssignment AnalysisResult.[edge1.Q1] edge1) AnalysisResult.[edge1.Q2] then
                                 Analysis edgeL Edges
                             else
                                 oldSet <- AnalysisResult.[edge1.Q2]
                                 AnalysisResult.Remove edge1.Q2
                                 AnalysisResult.Add(edge1.Q2, (Set.union oldSet (TF_ArrayAssignment AnalysisResult.[edge1.Q1] edge1)))
                                 Analysis Edges Edges
 
let AnalyseEdges Edges = Analysis Edges Edges
