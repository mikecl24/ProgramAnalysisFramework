#r "FsLexYacc.Runtime.dll"          // Load in FsLexYacc dll

open Microsoft.FSharp.Text.Lexing   // Lexing Library
open System


#load "Types.fs"
open Types                          // Module with all the types

#load "MicroCParser.fs"
open MicroCParser                   // Generated Parser

#load "MicroCLexer.fs"
open MicroCLexer                    //Generated Lexer

#load "Parser.fs"                   // Parser Implementation:
open Parser                         // Program String -> Statement List

#load "Grapher.fs"                  // Graph Generator:
open Grapher                        // Statement List -> Program Graph 


let programString = "
x:=1;
A[1]:=2
"

(* Program String -> Statement List *)
let stmtList = ParseString programString

(* Statement List -> Program Graph *)
let Edges:Edge list = GraphStatements stmtList
printfn "%A" Edges


(* Node list generated by Grapher *)
let Nodes : Node list = ExtractNodes Edges
// printfn "%A" Nodes

(* Variable list from Grapher *)
let Variables : Var list = uniqueVars vartemp
// printfn "%A" Variables

// MetaL Parser -> Generate Domain
// Quickchecking domain?

#load "LattOps.fs"                   // Lattice Operation functions
open LatticeOperations               // Union, Intersection, Subset, Superset

#load "Domain.fs"                   // Domain Specification Generated code
open Domain                         // Q -> Domain variable + types


// Pause
// TF class generation

#load "TransferFunctions2.fs"        // Transfer Function Specification
open TransferFunctions              // iota, init


// QuickChecking Module
(**)
#load "Analysis2.fs"                 // Analysis Implementation:
open Analysis                       // Program Graph -> Analysis Result



// Program Graph -> Analysis Result
let Analysis = AnalyseEdges Edges // union/intersection function, sub/super -seteq function

printfn "Result:"
printfn "%A" (Seq.toList (Analysis))
//printfn "%A" Analysis.[3]
