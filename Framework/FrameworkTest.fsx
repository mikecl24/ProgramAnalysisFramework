#r "FsLexYacc.Runtime.dll"          // Load in FsLexYacc dll

open Microsoft.FSharp.Text.Lexing   // Lexing Library
open System
open System.IO                      // File Handling

(*-----------------------------------------------------------------*)

#load "Types.fs"
open Types                          // Module with types

#load "ExtWParser.fs"
open ExtWParser                   // Generated Parser from .fsp file

#load "ExtWLexer.fs"
open ExtWLexer                    //Generated Lexer from .fsl file

#load "Parser.fs"                   // Parser Implementation:
open Parser                         // Program String -> Statement List

#load "Grapher.fs"                  // Graph Generator:
open Grapher                        // Statement List -> Program Graph 

(*-----------------------------------------------------------------*)

(* File -> Program String *)
let programString : string = File.ReadAllText("Program.extw")

(* Program String -> Statement List *)
let stmtList : Statement list = ParseString programString

(* Statement List -> Program Graph *)
let Edges : Edge list = GraphStatements stmtList
//printfn "%A" Edges


(* Node list generated by Grapher *)
let Nodes : Node list = ExtractNodes Edges
// printfn "%A" Nodes

(* Variable list from Grapher *)
let Variables : Var list = uniqueVars vartemp
// printfn "%A" Variables

// MetaL Parser -> Generate Domain
// Quickchecking domain?

#load "LattOps.fs"                   // Lattice Operation functions
open LatticeOperations               // Union, Intersection, Subset, Superset

#load "Domain.fs"                   // Domain Specification Generated code
open Domain                         // Q -> Domain variable + types


// Pause
// TF class generation

#load "TransferFunctions2.fs"        // Transfer Function Specification
open TransferFunctions              // iota, init


// QuickChecking Module
(**)
#load "Analysis.fs"                 // Analysis Implementation:
open Analysis                       // Program Graph -> Analysis Result



// Program Graph -> Analysis Result
let Analysis : AnalysisResult = AnalyseEdges Edges // union/intersection function, sub/super -seteq function


let format text (chars:string) =
    Array.fold (
        fun (s:string) c -> s.Replace(c.ToString(),"").Replace("};", "};\n\t\t")
    ) text (chars.ToCharArray())

printfn "RESULT:"
Analysis |> Seq.iter (fun x -> (printfn "%A\t->\t%s" x.Key (format (x.Value.ToString()) "\n")); printfn "\n")
//printfn "%A" (Seq.toList (Analysis))
//printfn "%A" Analysis.[3]
